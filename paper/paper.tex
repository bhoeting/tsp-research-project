
% Preamble
% ---
\documentclass[11pt,fleqn]{article}

% Packages
% ---
\usepackage[
  left=3cm,
  right=3cm,
  top=2cm,
  bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage{clrscode3e}
\usepackage{blkarray}
\usepackage{booktabs}
\usepackage{parskip}
\usepackage{mathptmx}
\usepackage{bigstrut}
\usepackage{mathptmx}
\usepackage{minted}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}


% Use borland colorscheme in minted.
\usemintedstyle{borland}


% Document
% ---
\begin{document}

\title{Exploring the Traveling Salesman Problem}
\author{Brennan Hoeting}
\date{}
\maketitle

\section*{Introduction}
This paper will explore the Traveling Salesman Problem (TSP),
a classic NP---hard problem in the field of computer science.
We will first obtain an understanding of the problem. That
is, we will explain the problem, examine its input and output,
and show why solving this problem particularly challenging.
We will present and explain a naive brute force solution to the
problem and analyze it's efficiency.  We will present a better
method for solving the TSP, the Held---Karp algorithm, and explain
it in detail mathematically and with pseudocode.  There is a
smorgasbord of algorithms that improve over the brute force method,
but they all have their drawbacks and none of them run in a polynomial
time complexity.  We will examine a few of these methods in lesser
detail than Held---Karp and look at situations in which one algorithm
is favorable over another.

\section{Understanding the Problem}
\subsection{Overview}
The traveling salesman problem can be described as follows:
Given a set of cities, where there is a distance between
each pair of cities, find a tour (route) that begins at a
starting city, visits each \textit{destination city} exactly once,
and returns to the starting city with the minimum possible
total distance traveled.  We will refer to the tour with the
minimum possible distance traveled as the \textit{optimal tour}.

\subsection{Problem Input}
The problem input is a matrix that defines the distance
between each pair of cities.  We will denote this as
the distance matrix $D = (d_{ij})$, where $d_{ij}$ is
the distance between city $i$ and city $j$.  It is important
to note that the cost (distance) from city $i$ to city $j$ is equal
to the cost from city $j$ to city $i$. This means that our
TSP variation is \textit{undirected}, so we may use a diagnol
matrix to represent the distances.  That is, for every $d_{ij}$
where $i<j$, $d_{ij}$ is the distance between cities $i$ and $j$,
and every $d_{ij}$ where $i\geq j$, is ignored.
\par

In a \textit{directed} variation of the TSP --- such as one that
optimizes for minimum total airfair to travel a tour by plane,
where ticket prices from city $i$ to city $j$ is not necessarily
equal to the ticket price from city $j$ to city $i$ --- we would
store a cost in every value of $d_{ij}$ where $i\neq j$, rather
than storing the costs in a diagnol matrix.  This distinction,
while helpful to be aware of, minimally affects how the problem is
solved in the methods we will explore.
\par

See below for a valid input example for an undirected TSP variation.
Notice, for example, that the distance between city $1$ and city $4$ is
$d_{1,4}=29$.  If we ran into a case while implementing a TSP algorithm
where we are finding the distance between $i$ and $j$ but $j>i$, we
simply retrieve the distance from $d_{ji}$ instead of $d_{ij}$.
\par

\begin{align*}
  d_{ij}=
  \begin{blockarray}{cccccc}
    & j_1 & j_2 & j_3 & j_4 & j_5 \\
  \begin{block}{c(ccccc)}
    i_1 & \cdot & 7 & 37 & 29 & 17 \\
    i_2 & \cdot & \cdot & 31 & 32 & 34 \\
    i_3 & \cdot & \cdot & \cdot & 32 & 42 \\
    i_4 & \cdot & \cdot & \cdot & \cdot & 20 \\
    i_5 & \cdot & \cdot & \cdot & \cdot & \cdot \\
  \end{block}
  \end{blockarray}
\end{align*}

\subsection{Problem Output}
The output for the TSP is also a matrix with the dimensions
$N\times N$, where $N$ is the number of cities.  We will define the output as
the edge matrix $E = (e_{ij})$, where $e_{ij}=1$ if the optimal tour involves
traveling from city $i$ to city $j$.  $e_{ij}=0$ if meaning we will not
travel from city $i$ to city $j$ along the optimal tour.
\par

We use an edge matrix because if we had a graph $G=(V,E)$, $V_i$
would represent city $i$ and $E_{ij}$ would
represent traveling from city $i$ to city $j$ along the optimal tour.
If the graph where visualized, each verticy would be positioned at its
longitude and latitude coordinates and a segment would connect each pair
of verticies $v_i$ and $v_j$ where $e_{ij}=1$.
\par

Below is an example of a valid output for our TSP variation.  Notice that
$e_{3,4}=1$ implying our optimal tour involves traveling from city $3$ to
city $4$.  Observe that when $i<j$, just as the distance matrix $d_{ij}$,
the value in $e_{ij}$ is not used, resulting in another diagonal matrix.
Observe that $e_1$ has two columns that are $1$.  This will always be the
case for a single $e_i$ where $i$ is the city at we we begin and terminate
the tour.  In this case, and throughout the paper, the optimal tour will
always start and end on the first city.
\par

\begin{align*}
  e_{ij}=
  \begin{blockarray}{cccccc}
    & j_1 & j_2 & j_3 & j_4 & j_5 \\
  \begin{block}{c(ccccc)}
    i_1 & \cdot & 1 & 0 & 0 & 1 \\
    i_2 & \cdot & \cdot & 1 & 0 & 0 \\
    i_3 & \cdot & \cdot & \cdot & 1 & 0 \\
    i_4 & \cdot & \cdot & \cdot & \cdot & 1 \\
    i_5 & \cdot & \cdot & \cdot & \cdot & \cdot \\
  \end{block}
  \end{blockarray}
\end{align*}


\section{A Naive Brute Force Algorithm}
\subsection{Overview}
The brute force method for solving the Traveling Salesman Problem has exactly
two redeeming qualities: (1) it is quite simple, making implementation
trivial, and (2) it will produce the correct tour in every TSP instance.
Unfortunately, for instances that contain more than roughly 10 cities, the
algorithm does not finish execution in a reasonable time.  Analyzing the
pseudocode in (2.2), we can get a good idea of why this is the case.
\par
\vspace{0.5cm}


\subsection{Pseudocode}
\begin{codebox}
\Procname{$\proc{OPTIMAL-TOUR}(D:$ distance matrix$)$}
\li $\id{T} \gets$ all permutations of $[2 \twodots \attrib{D}{length}]$
\li $\id{min-dist} \gets \infty$
\li $\id{min-tour} \gets \const{nil}$
\li \For each tour $t \in T$
\li   \Do
        $\id{t} \gets [1] + T + [1]$
\li       $\id{dist} \gets \proc{TOUR-DISTANCE}(D, t)$
\li	  \If $dist < \id{min-dist}$
\li	    \Then
              $\id{min-dist} \gets dist$
\li	      $\id{min-tour} \gets tour$
            \End
       \End

\li    \Return $\proc{MAKE-EDGE-MATRIX}(\id{min-tour})$
\end{codebox}
 
On line $1$, we assign $\id{T}$ to a list containing each permutation of
the seed list $[2 \twodots \attrib{D}{length}]$.  Each list $T_k$ represents
a partial tour such that $T_{k,i+1}$ is visited from $T_{k,i}$.  Each element
$T_{k,i}$ in $T_k$ corresponds to a row index $i$ in the distance matrix $D$.
\par

Notice that we initially exclude our starting city, $1$, from the seed list.
This is to ensure $T$ only includes permutations the destination cities. Next,
for each permutation $t$ in $T$, we append $1$ to the front and back of $t$.
This gives us a complete tour, starting on $1$, visiting each destination
exactly once, and ending on $1$.  Now we may calculate the total distance,
$\id{dist}$, of $t$ by calling the $\proc{TOUR-DISTANCE}(D, t)$ procedure,
which is simply:

\vspace{.27cm}
\hrule
\begin{codebox}
\Procname{$\proc{TOUR-DISTANCE}(t:$ tour, $D:$ distance matrix$)$}
\li $\id{dist} \gets 0$
\li \For $\id{i} \gets 2$ to $\attrib{t}{length}$
\li   \Do
$\id{dist} \gets \id{dist} + D_{\proc{min}(t_{i-1}, t_i), \proc{max}(t_{i-1}, t_i)}$
       \End
\li    \Return $\id{dist}$
\end{codebox}
\vspace{.1cm}
\hrule
\vspace{.05cm}

If $\id{dist} < \id{min-dist}$, we update
$\id{min-dist}$ and $\id{min-tour}$.  Once the loop is finished, we
return an edge matrix to represent the optimal tour using the
$\proc{MAKE-EDGE-MATRIX}()$ procedure, which creates an edge matrix from a tour
represented as a list.
\par


\subsection{Runtime}
Looking at the table below, we can see how the number of potential optimal
paths increases as the number of cities increases.
\par

\bgroup
\def\arraystretch{1.25}
\begin{tabular}{c|r}
  Cities $n$ & Possible Tours $(n-1){!}$ \\
  \hline
  \begin{tabular}{c}
    $4$ \\
    $5$ \\
    $\dots$ \\
    $10$ \\
    $11$ \\
    $12$
  \end {tabular}
  &
  \begin{tabular}{r@{\;{=}\;}l}
    $(4-1){!}$ & $6$ \\
    $(5-1){!}$ & $24$ \\
    $\dots$ & $\dots$ \\
    $(10-1){!}$ & $362,880$ \\
    $(11-1){!}$ & $3,628,800$ \\
    $(12-1){!}$ & $39,916,800$
  \end{tabular}

\end{tabular}
\egroup

The runtime of this method is upper bounded by the amount
of time it takes to generate each possible tour, so we can
say the algorithm is $O((n-1)!) = O(n!)$, where $n$ is the
number of cities.
\par


\section{A More Thoughtful Solution}

% Appendicies
% ---
\newpage
\appendix
\section{Appendices}
\addcontentsline{toc}{section}{Appendices}
\renewcommand{\thesubsection}{\Alph{subsection}}

\subsection{Collaboration}
  I collaborated with Grant Eaton and Luke Artnak.

\newpage
\subsection{Code Demonstration}
  \inputminted[frame=lines,linenos=true]{python}{../src/brute_force.py}


\end{document}
