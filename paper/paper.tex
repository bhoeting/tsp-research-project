
%\documentclass[margin, 11pt]{article}
\documentclass{article}
\usepackage[left=3cm,right=3cm,top=2cm,bottom=2cm]{geometry}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage{clrscode3e}
\usepackage{blkarray}
\usepackage{booktabs}
\usepackage{parskip}
\usepackage{mathptmx}
\usepackage{bigstrut}
\usepackage{mathptmx}
\usepackage{minted}
\usemintedstyle{borland}


\begin{document}

\title{Exploring the Traveling Salesman Problem}
\author{Brennan Hoeting}
\date{}
\maketitle

\section*{Introduction}
This paper will explore the Traveling Salesman Problem (TSP).
We will first obtain an understanding of the problem, that
is, we will explain the problem, examine its input and output,
and identify what makes solving this problem particularly
challenging.  Next, we will present a naive brute force solution
to the problem and analyze it's efficiency and correctness.  We
will improve upon that solution by comparing and contrasting
more efficient approaches to solving the problem.  We will choose
an efficient solution to present, explain, and compare runtimes
against naive solution.  We will prove that our efficient solution
can solve a subclass of instances of the Traveling Salesman Problem.
Finally, Python code for the naive and efficient solutions will be
presented and demonstrated.

\section*{Understanding the Problem}
The traveling salesman problem can be described as follows:
Given a set of cities, where there is a distance between
each pair of cities, find a tour one could take that
begins at a starting city, visits each destination city
exactly once, and returns to the starting city with the
minimum possible total distance traveled.  We will refer
to the tour with the minimum possible distance traveled
as the \textit{optimal tour}.
\par

The problem input is a matrix that defines the distance
between each pair of cities.  We will denote this as
the distance matrix $D = (d_{ij})$, where $d_{ij}$ is
the distance between city $i$ and city $j$.  It is important
to note that the distance from city $i$ to city $j$ is equal
to the distance from city $j$ to city $i$. This means that our
TSP variation is \textit{undirected} so we may use a diagnol
matrix to represent the distances.  That is, for every $d_{ij}$
where $i<j$, $d_{ij}$ is the distance between cities $i$ and $j$,
and every $d_{ij}$ where $i\geq j$, $d_{ij} = 0$.  In a \textit{directed}
variation of the TSP --- such as one that optimizes for minimum total
airfair to travel the tour by plane, where ticket prices from city
$i$ to city $j$ is not necessarily equal to the ticket price from
city $j$ to city $i$ --- we could not store the costs in a diagnol
matrix.  See below for a valid input example of our TSP variation.
Notice, for example, that the distance between city $1$ and city $4$
is $d_{1,4}=29$.  Observe that when $i<j$ $d_{ij}=0$, implying
we will ignore distance between $i$ and $j$, either because $i=j$
(meaning we don't travel from city $i$ to city $i$) or because $j>i$,
in which case the distance can be found elsewhere in the matrix.
\par

\begin{align*}
  d_{ij}=
  \begin{blockarray}{cccccc}
    & j_1 & j_2 & j_3 & j_4 & j_5 \\
  \begin{block}{c(ccccc)}
    i_1 & \cdot & 7 & 37 & 29 & 17 \\
    i_2 & \cdot & \cdot & 31 & 32 & 34 \\
    i_3 & \cdot & \cdot & \cdot & 32 & 42 \\
    i_4 & \cdot & \cdot & \cdot & \cdot & 20 \\
    i_5 & \cdot & \cdot & \cdot & \cdot & \cdot \\
  \end{block}
  \end{blockarray}
\end{align*}

Similarly, the output for the TSP is also a matrix with the dimensions
$N\times N$, where $N$ is the number of cities.  We will define this as
the edge matrix $E = (e_{ij})$, where $e_{ij}=1$ if the optimal tour involves
going from city $i$ to city $j$.  Otherwise, $e_{ij}=0$, meaning we will not
travel from city $i$ to city $j$.  We call this an edge matrix because if
we had a graph $G=(V,E)$, $V_i$ would represent city $i$ and $E_{ij}$ would
represent traveling from city $i$ to city $j$ as part of our optimal tour.
If the graph where visualized, each verticy would be positioned at its
longitude and latitude coordinates, and an edge would connect each pair of
verticies $v_i$ and $v_j$ where $e_{ij}=1$.  We will see this visual
representation of the optimal tour as part of the code demonstration.
Below is an example of valid output for our TSP variation.  Notice that
$e_{3,4}=1$ implying our optimal tour entails traveling from city $3$ to
city $4$.  Observe that when $i<j$, just as the distance matrix $d_{ij}$,
the value in $e_{ij}$ is not used, resulting in another diagonal matrix.
\par

\begin{align*}
  e_{ij}=
  \begin{blockarray}{cccccc}
    & j_1 & j_2 & j_3 & j_4 & j_5 \\
  \begin{block}{c(ccccc)}
    i_1 & \cdot & 1 & 0 & 0 & 1 \\
    i_2 & \cdot & \cdot & 1 & 0 & 0 \\
    i_3 & \cdot & \cdot & \cdot & 1 & 0 \\
    i_4 & \cdot & \cdot & \cdot & \cdot & 1 \\
    i_5 & \cdot & \cdot & \cdot & \cdot & \cdot \\
  \end{block}
  \end{blockarray}
\end{align*}

Now that the Traveling Salesman Problem is defined, we shall proceed by
exploring different methods for arriving at a solution.

\section*{A Naive Brute Force Algorithm}
The brute force method for solving the Traveling Salesman Problem has exactly
two redeeming qualities: (1) it is quite simple, making implementation
trivial, and (2) it will produce the correct tour in every TSP instance.
Unfortunately, for instances that contain more than roughly 10 cities, the
algorithm does not finish execution.  To see why this is the case, we will
analyze the psuedocode below:
\par
\vspace{0.5cm}


\begin{codebox}
\Procname{$\proc{FIND-OPTIMAL-TOUR}(D:$ distance matrix$)$}
\li $\id{T} \gets$ all permutations of $[2 \twodots \attrib{D}{length}]$
\li $\id{min-dist} \gets \infty$
\li $\id{min-tour} \gets \const{nil}$
\li \For each tour $t \in T$
\li   \Do
        $\id{t} \gets [1] + T + [1]$
\li       $\id{dist} \gets \proc{TOUR-DISTANCE}(D, t)$
\li	  \If $dist < \id{min-dist}$
\li	    \Then
              $\id{min-dist} \gets dist$
\li	      $\id{min-tour} \gets tour$
            \End
       \End

\li   \Return $\proc{MAKE-EDGE-MATRIX}(t)$
\end{codebox}
\vspace{0.5cm}

On line $1$, we generate a list containing each permutation of
$[2 \twodots \attrib{D}{length}]$.  Our starting point is at city
$1$, so we omit it when generating the permutations since it should
be the first and last element of each possible tour.  On line $5$,
we insert the starting point $1$ in the front and back of the tour
before calculating the tour distance.  Then we simply update $\id{min-tour}$
and $\id{min-dist}$ as we encounter a more optimal tour.  To understand
how the runtime of this algorithm grows as the problem size increases
(i.e.\ as the number of cities increases), refer to the table below:
\par
\vspace{0.25cm}

\bgroup
\def\arraystretch{1.00}
\begin{tabular}{c|r}
  \# of cities $n$ & \# of possible tours $(n-1){!}$ \\
  \hline
  \begin{tabular}{c}
    4 \\
    5 \\
    6 \\
    7 \\
    8 \\
    9 \\
    10 \\
    11 \\
    12
  \end {tabular}
  &
  \begin{tabular}{r@{\;{=}\;}l}
    $( 4-1){!}$ & $6$ \\
    $(5-1){!}$ & $24$ \\
    $(6-1){!}$ & $120$ \\
    $(7-1){!}$ & $720$ \\
    $(8-1){!}$ & $5040$ \\
    $(9-1){!}$ & $40,320$ \\
    $(10-1){!}$ & $362,880$ \\
    $(11-1){!}$ & $3,628,800$ \\
    $(12-1){!}$ & $39,916,800$
  \end{tabular}

\end{tabular}
\egroup

Since the runtime of this algorithm is bounded
by the number of possible tours, we can say it has
an upper bound of $O(n!)$.  This is unsurprising
for a brute force algorithm.  We will now explore
a more efficient solution to the Traveling Salesman
Problem so we may solve instances with more than 12
cities in a reasonable runtime.

\section*{A More Thoughtful Solution}
\newpage

\section*{Appendix A}

\newpage

\section*{Appendix B}
\inputminted[frame=lines,linenos=true]{python}{../src/brute_force.py}

\end{document}
