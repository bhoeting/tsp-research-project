
% Preamble
% ---
\documentclass[11pt,fleqn]{article}

% Packages
% ---
\usepackage[
  left=3cm,
  right=3cm,
  top=2cm,
  bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{enumerate}
\usepackage{clrscode3e}
\usepackage{blkarray}
\usepackage{booktabs}
\usepackage{parskip}
\usepackage{mathptmx}
\usepackage{bigstrut}
\usepackage{mathptmx}
\usepackage{minted}


% Use borland colorscheme in minted.
\usemintedstyle{borland}


% Document
% ---
\begin{document}

\title{Exploring the Traveling Salesman Problem}
\author{Brennan Hoeting}
\date{}
\maketitle

\section*{Introduction}
This paper will explore the Traveling Salesman Problem (TSP),
a classic NP---hard problem in the field of computer science.
We will first obtain an understanding of the problem. That
is, we will explain the problem, examine its input and output,
and show why solving this problem particularly challenging.
We will present and explain a naive brute force solution to the
problem and analyze it's efficiency.  We will present a better
method for solving the TSP, the Held---Karp algorithm, and explain
it in detail mathematically and with psuedocode.  There is a 
smorgasbord of algorihtms that imporve over the brute force method,
but they all have their drawbacks and none of them run in polynommial
time complexity.  We will examine a few of these methods in lesser
detail than Held---Karp and look at situtations in which one algorithm
is favorable over another.

\section{Understanding the Problem}
\subsection{Overview}
The traveling salesman problem can be described as follows:
Given a set of cities, where there is a distance between
each pair of cities, find a tour (route) that begins at a
starting city, visits each destination city exactly once,
and returns to the starting city with the minimum possible
total distance traveled.  We will refer to the tour with the
minimum possible distance traveled as the \textit{optimal tour}.

\subsection{Problem Input}
The problem input is a matrix that defines the distance
between each pair of cities.  We will denote this as
the distance matrix $D = (d_{ij})$, where $d_{ij}$ is
the distance between city $i$ and city $j$.  It is important
to note that the cost (distance) from city $i$ to city $j$ is equal
to the cost from city $j$ to city $i$. This means that our
TSP variation is \textit{undirected}, so we may use a diagnol
matrix to represent the distances.  That is, for every $d_{ij}$
where $i<j$, $d_{ij}$ is the distance between cities $i$ and $j$,
and every $d_{ij}$ where $i\geq j$, is ignored.
\par

In a \textit{directed} variation of the TSP --- such as one that
optimizes for minimum total airfair to travel a tour by plane,
where ticket prices from city $i$ to city $j$ is not necessarily
equal to the ticket price from city $j$ to city $i$ --- we would
store the cost in every value of $d_{ij}$ where $i\neq $j, rather
than storing the costs in a diagnol matrix.  This distinction,
while helpful to be aware of, minimally affects how the problem is
solved in the methods we will explore.

\par

See below for a valid 
input example of our TSP variation.  Notice, for example, that the
distance between city $1$ and city $4$ is $d_{1,4}=29$.  If we ran
into a case while implementing the algorithm where we are finding
the distance between $i$ and $j$ but $j>i$, we simply get the distance
from $d_{ji}$ instead of $d_{ij}$.
\par

\begin{align*}
  d_{ij}=
  \begin{blockarray}{cccccc}
    & j_1 & j_2 & j_3 & j_4 & j_5 \\
  \begin{block}{c(ccccc)}
    i_1 & \cdot & 7 & 37 & 29 & 17 \\
    i_2 & \cdot & \cdot & 31 & 32 & 34 \\
    i_3 & \cdot & \cdot & \cdot & 32 & 42 \\
    i_4 & \cdot & \cdot & \cdot & \cdot & 20 \\
    i_5 & \cdot & \cdot & \cdot & \cdot & \cdot \\
  \end{block}
  \end{blockarray}
\end{align*}

\subsection{Problem Output}
Similarly, the output for the TSP is also a matrix with the dimensions
$N\times N$, where $N$ is the number of cities.  We will define this as
the edge matrix $E = (e_{ij})$, where $e_{ij}=1$ if the optimal tour involves
going from city $i$ to city $j$.  Otherwise, $e_{ij}=0$, meaning we will not
travel from city $i$ to city $j$.  We call this an edge matrix because if
we had a graph $G=(V,E)$, $V_i$ would represent city $i$ and $E_{ij}$ would
represent traveling from city $i$ to city $j$ as part of our optimal tour.
If the graph where visualized, each verticy would be positioned at its
longitude and latitude coordinates, and an edge would connect each pair of
verticies $v_i$ and $v_j$ where $e_{ij}=1$.  We will see this visual
representation of the optimal tour as part of the code demonstration.
Below is an example of valid output for our TSP variation.  Notice that
$e_{3,4}=1$ implying our optimal tour entails traveling from city $3$ to
city $4$.  Observe that when $i<j$, just as the distance matrix $d_{ij}$,
the value in $e_{ij}$ is not used, resulting in another diagonal matrix.
\par

\begin{align*}
  e_{ij}=
  \begin{blockarray}{cccccc}
    & j_1 & j_2 & j_3 & j_4 & j_5 \\
  \begin{block}{c(ccccc)}
    i_1 & \cdot & 1 & 0 & 0 & 1 \\
    i_2 & \cdot & \cdot & 1 & 0 & 0 \\
    i_3 & \cdot & \cdot & \cdot & 1 & 0 \\
    i_4 & \cdot & \cdot & \cdot & \cdot & 1 \\
    i_5 & \cdot & \cdot & \cdot & \cdot & \cdot \\
  \end{block}
  \end{blockarray}
\end{align*}

Now that the Traveling Salesman Problem is defined, we can proceed by
exploring different methods for computing the optimal solution.

\section{A Naive Brute Force Algorithm}
The brute force method for solving the Traveling Salesman Problem has exactly
two redeeming qualities: (1) it is quite simple, making implementation
trivial, and (2) it will produce the correct tour in every TSP instance.
Unfortunately, for instances that contain more than roughly 10 cities, the
algorithm does not finish execution.  To see why this is the case, we will
analyze the psuedocode below:
\par
\vspace{0.5cm}


\begin{codebox}
\Procname{$\proc{FIND-OPTIMAL-TOUR}(D:$ distance matrix$)$}
\li $\id{T} \gets$ all permutations of $[2 \twodots \attrib{D}{length}]$
\li $\id{min-dist} \gets \infty$
\li $\id{min-tour} \gets \const{nil}$
\li \For each tour $t \in T$
\li   \Do
        $\id{t} \gets [1] + T + [1]$
\li       $\id{dist} \gets \proc{TOUR-DISTANCE}(D, t)$
\li	  \If $dist < \id{min-dist}$
\li	    \Then
              $\id{min-dist} \gets dist$
\li	      $\id{min-tour} \gets tour$
            \End
       \End

\li   \Return $\proc{MAKE-EDGE-MATRIX}(t)$
\end{codebox}
\vspace{0.5cm}

On line $1$, we generate a list containing each permutation of
$[2 \twodots \attrib{D}{length}]$.  Our starting point is at city
$1$, so we omit it when generating the permutations since it should
be the first and last element of each possible tour.  On line $5$,
we insert the starting point $1$ in the front and back of the tour
before calculating the tour distance.  Then we simply update $\id{min-tour}$
and $\id{min-dist}$ as we encounter a more optimal tour.
\par


Looking at the table below, we can see how the number of potential optimal
paths increases as the number of cities increases.
\par
\vspace{0.25cm}

\bgroup
\def\arraystretch{1.5}
\begin{tabular}{c|r}
  Cities $n$ & Possible Tours $(n-1){!}$ \\
  \hline
  \begin{tabular}{c}
    4 \\
    5 \\
    6 \\
    7 \\
    8 \\
    9 \\
    10 \\
    11 \\
    12
  \end {tabular}
  &
  \begin{tabular}{r@{\;{=}\;}l}
    $( 4-1){!}$ & $6$ \\
    $(5-1){!}$ & $24$ \\
    $(6-1){!}$ & $120$ \\
    $(7-1){!}$ & $720$ \\
    $(8-1){!}$ & $5040$ \\
    $(9-1){!}$ & $40,320$ \\
    $(10-1){!}$ & $362,880$ \\
    $(11-1){!}$ & $3,628,800$ \\
    $(12-1){!}$ & $39,916,800$
  \end{tabular}

\end{tabular}
\egroup
\vspace{0.25cm}

The runtime of this algorithm is bounded by the amount
of time it takes to generate each possible tour.
Therefore, we may informally say that the upper runtime
bound for the runtime is $O(n!)$, where $n$ is the
number of cities.

\par


\section{A More Thoughtful Solution}

% Appendicies
% ---
\newpage
\appendix
\section{Appendices}
\addcontentsline{toc}{section}{Appendices}
\renewcommand{\thesubsection}{\Alph{subsection}}

\subsection{Collaboration}
  I collaborated with Grant Eaton and Luke Artnak.

\newpage
\subsection{Code Demonstration}
  \inputminted[frame=lines,linenos=true]{python}{../src/brute_force.py}


\end{document}
